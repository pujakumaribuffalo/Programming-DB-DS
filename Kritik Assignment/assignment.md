- https://www.markdownguide.org/basic-syntax/
- https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one
  

# Kritik Assignments
1. There is a creation stage -- where you answer the questions
2. There is a evaluation stage -- where you grade your peers, three peers
3. There is a feedback stage -- where you provide feedback to your evaluator 
4. You can raise an objection to your grade and we can then review your submission

# Part 1

```python
values = (ele for ele in range(10))
a = []
b = []
for value in values:
    a.append(value * value)
    
for value in values:
    b.append(value + value)
```

1. What is the value of `a` and `b` and EXPLAIN why that is the case?
   
   The value of a would be [0, 1, 4, 9, 16, 25, 36, 49, 64, 81] which represents the squares of the values generated by the range(10) function.  The value of b would be an empty list []. This is because the generator values has been exhausted in the first for-loop where all the values have been consumed by the list a, and there are no values left for the second for-loop to iterate over.

2. How would you "fix" the code?
   
   To fix this code, we can either convert the generator values to a list so that it can be iterated over multiple times, or it can be done by creating a new generator for the second loop.
   
    1.) Convert the generator values to a list 
   ```python
    values = (ele for ele in range(10))
    a = []
    b = []
    for value in values:
        a.append(value * value)

    # convert the generator to a list
    values = list(range(10))

    for value in values:
        b.append(value + value)
    print(a) # Output: [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
    print(b) # Output: [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
   ```
    2.) By creating a new generator for the second loop
    
    ```python
    values = (ele for ele in range(10))
    a = []
    b = []
    for value in values:
        a.append(value * value)

    # create a new generator for the second loop
    values = (ele for ele in range(10))

    for value in values:
        b.append(value + value)
    print(a) # Output: [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
    print(b) # Output: [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
   ```

  


# Part 2

```python
class MyRange:
    
    def __init__(self, limit):
        self.limit = limit
        self.value = 0
        
    def __iter__(self):
        
        return self
    
    def __next__(self):
        if self.value < self.limit:
            return_value = self.value
            self.value += 1
            return return_value
        else:
            raise StopIteration
            
values = MyRange(10)
a = []
b = []
for value in values:
    a.append(value * value)
    
for value in values:
    b.append(value + value)
```

1. What is the value of `a` and `b` and EXPLAIN why that is the case?
   
   The value of a is [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]. The value of b is [].
   This is because MyRange is an iterator that generates a sequence of numbers from 0 up to the limit specified when the object is instantiated. In this case, limit is set to 10.

   When the for loop iterates over values and calculates the square of each number, it exhausts the iterator by incrementing 
   self.value until it reaches limit. Therefore, when the second for loop iterates over values, it finds that the iterator is already exhausted and there are no more numbers to generate. Hence, b remains empty.

2. How would you fix the code?
   
   To fix this code, we need to ensure that each for loop starts with a new instance of MyRange rather than reusing the same instance or we can modify the __iter__ method of MyRange to reset self.value to 0 whenever a new instance is created. This would allow the same instance to be used in both for loops.
   
 1.) By creating a new instance of MyRange rather than reusing the same instance
```python
    class MyRange:
         
        def __init__(self, limit):
            self.limit = limit
            self.value = 0
             
        def __iter__(self):
             
            return self
         
        def __next__(self):
            if self.value < self.limit:
                return_value = self.value
                self.value += 1
                return return_value
            else:
                raise StopIteration
                 
    values = MyRange(10)
    a = []
    b = []
    for value in MyRange(10):
        a.append(value * value)
         
    for value in MyRange(10):
        b.append(value + value)
    print(a) # Output: [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
    print(b) # Output: [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
```

   2.) By modifying the __iter__ method of MyRange to reset self.value to 0 whenever a new instance is created. This would allow   the same instance to be used in both for loops

```python
    class MyRange:
         
        def __init__(self, limit):
            self.limit = limit
            
             
        def __iter__(self):
            self.value = 0 
            return self
         
        def __next__(self):
            if self.value < self.limit:
                return_value = self.value
                self.value += 1
                return return_value
            else:
                raise StopIteration
                 
    values = MyRange(10)
    a = []
    b = []
    for value in values:
        a.append(value * value)
     
    for value in values:
        b.append(value + value)
    print(a) # Output: [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
    print(b) # Output: [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
```